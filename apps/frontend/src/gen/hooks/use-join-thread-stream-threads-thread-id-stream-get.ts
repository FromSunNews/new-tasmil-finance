/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import fetch from "@kubb/plugin-client/clients/axios";
import type { JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, JoinThreadStreamThreadsThreadIdStreamGetPathParams, JoinThreadStreamThreadsThreadIdStreamGetQueryParams, JoinThreadStreamThreadsThreadIdStreamGetHeaderParams, JoinThreadStreamThreadsThreadIdStreamGet404, JoinThreadStreamThreadsThreadIdStreamGet422 } from "@/gen/types/join-thread-stream-threads-thread-id-stream-get";
import type { RequestConfig, ResponseErrorConfig } from "@kubb/plugin-client/clients/axios";
import type { QueryKey, QueryClient, QueryObserverOptions, UseQueryResult } from "@tanstack/react-query";
import { joinThreadStreamThreadsThreadIdStreamGet } from "@/gen/client/join-thread-stream-threads-thread-id-stream-get";
import { queryOptions, useQuery } from "@tanstack/react-query";

export const joinThreadStreamThreadsThreadIdStreamGetQueryKey = (thread_id: JoinThreadStreamThreadsThreadIdStreamGetPathParams["thread_id"], params?: JoinThreadStreamThreadsThreadIdStreamGetQueryParams) => [{ url: '/threads/:thread_id/stream', params: {thread_id:thread_id} }, ...(params ? [params] : [])] as const

export type JoinThreadStreamThreadsThreadIdStreamGetQueryKey = ReturnType<typeof joinThreadStreamThreadsThreadIdStreamGetQueryKey>

export function joinThreadStreamThreadsThreadIdStreamGetQueryOptions(thread_id: JoinThreadStreamThreadsThreadIdStreamGetPathParams["thread_id"], params?: JoinThreadStreamThreadsThreadIdStreamGetQueryParams, headers?: JoinThreadStreamThreadsThreadIdStreamGetHeaderParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = joinThreadStreamThreadsThreadIdStreamGetQueryKey(thread_id, params)
  return queryOptions<JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, ResponseErrorConfig<JoinThreadStreamThreadsThreadIdStreamGet404 | JoinThreadStreamThreadsThreadIdStreamGet422>, JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, typeof queryKey>({
   enabled: !!(thread_id),
   queryKey,
   queryFn: async ({ signal }) => {
      config.signal = signal
      return joinThreadStreamThreadsThreadIdStreamGet(thread_id, params, headers, config)
   },
  })
}

/**
 * @description This endpoint streams output in real-time from a thread. The stream will include the output of each run executed sequentially on the thread and will remain open indefinitely. It is the responsibility of the calling client to close the connection.
 * @summary Join Thread Stream
 * {@link /threads/:thread_id/stream}
 */
export function useJoinThreadStreamThreadsThreadIdStreamGet<TData = JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, TQueryData = JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, TQueryKey extends QueryKey = JoinThreadStreamThreadsThreadIdStreamGetQueryKey>(thread_id: JoinThreadStreamThreadsThreadIdStreamGetPathParams["thread_id"], params?: JoinThreadStreamThreadsThreadIdStreamGetQueryParams, headers?: JoinThreadStreamThreadsThreadIdStreamGetHeaderParams, options: 
{
  query?: Partial<QueryObserverOptions<JoinThreadStreamThreadsThreadIdStreamGetQueryResponse, ResponseErrorConfig<JoinThreadStreamThreadsThreadIdStreamGet404 | JoinThreadStreamThreadsThreadIdStreamGet422>, TData, TQueryData, TQueryKey>> & { client?: QueryClient },
  client?: Partial<RequestConfig> & { client?: typeof fetch }
}
 = {}) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? joinThreadStreamThreadsThreadIdStreamGetQueryKey(thread_id, params)

  const query = useQuery({
   ...joinThreadStreamThreadsThreadIdStreamGetQueryOptions(thread_id, params, headers, config),
   queryKey,
   ...queryOptions
  } as unknown as QueryObserverOptions, queryClient) as UseQueryResult<TData, ResponseErrorConfig<JoinThreadStreamThreadsThreadIdStreamGet404 | JoinThreadStreamThreadsThreadIdStreamGet422>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}